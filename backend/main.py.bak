import os
import json
import asyncio
from datetime import datetime
from typing import Optional, Dict
from fastapi import FastAP            await manager.send_status(websocket, "completed", "Task execution completed")
                
    except WebSocketDisconnect:
        print("Client disconnected")
    except asyncio.TimeoutError:
        await manager.send_status(websocket, "timeout", "Connection timed out")
    except Exception as e:
        error_message = str(e)
        print(f"An error occurred: {error_message}")
        await manager.send_status(websocket, "error", error_message)
    finally:
        # Cleanup
        interpreter.reset()
        manager.disconnect(websocket)
        print("Connection closed and interpreter reset.")ket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from interpreter import interpreter
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Constants
HEARTBEAT_INTERVAL = 30  # seconds
EXECUTION_TIMEOUT = 300  # seconds

app = FastAPI()

origins = [
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure the interpreter instance
# This will be configured once and reused for all connections.
# For a multi-user scenario, you'd create one instance per user/session.
interpreter.llm.model = "deepseek/deepseek-coder"
interpreter.llm.api_key = os.getenv("DEEPSEEK_API_KEY")
if os.getenv("DEEPSEEK_API_KEY") and not os.getenv("OPENAI_API_KEY"):
    os.environ["OPENAI_API_KEY"] = os.environ["DEEPSEEK_API_KEY"]
interpreter.llm.api_base = os.getenv("OPENAI_API_BASE")
interpreter.auto_run = True
interpreter.disable_telemetry = True

@app.get("/")
async def root():
    return {"message": "Mini-UFO 4 Backend is running and ready for WebSocket connections."}


class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[WebSocket, Dict] = {}

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections[websocket] = {
            "last_heartbeat": datetime.now(),
            "task": None,
            "status": "connected"
        }

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            del self.active_connections[websocket]

    async def send_status(self, websocket: WebSocket, status: str, details: Optional[str] = None):
        status_message = {
            "type": "status",
            "status": status,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        await websocket.send_text(json.dumps(status_message))

manager = ConnectionManager()

async def heartbeat_check():
    while True:
        await asyncio.sleep(HEARTBEAT_INTERVAL)
        current_time = datetime.now()
        for ws in list(manager.active_connections.keys()):
            try:
                if (current_time - manager.active_connections[ws]["last_heartbeat"]).seconds > HEARTBEAT_INTERVAL * 2:
                    await manager.send_status(ws, "timeout", "Connection timed out")
                    await ws.close()
                    manager.disconnect(ws)
                else:
                    await ws.send_text(json.dumps({"type": "heartbeat"}))
            except Exception:
                manager.disconnect(ws)

@app.on_event("startup")
async def startup_event():
    asyncio.create_task(heartbeat_check())

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            try:
                # Wait for a message or heartbeat
                data = await asyncio.wait_for(websocket.receive_text(), timeout=HEARTBEAT_INTERVAL * 2)
                
                # Update heartbeat timestamp
                manager.active_connections[websocket]["last_heartbeat"] = datetime.now()

                # Check if it's a heartbeat message
                try:
                    message = json.loads(data)
                    if message.get("type") == "heartbeat":
                        continue
                except json.JSONDecodeError:
                    pass  # Not a JSON message, treat as prompt

                # Process the prompt
                await manager.send_status(websocket, "processing", "Starting task execution")
                
                # The .chat() method returns a generator that yields messages
                for chunk in interpreter.chat(data, display=False, stream=True):
                    # Send status updates based on chunk type
                    if chunk.get("type") == "code":
                        await manager.send_status(websocket, "executing", "Running code")
                    await websocket.send_text(json.dumps(chunk))
                await websocket.send_json(chunk)

            # Signal the end of the stream
            await websocket.send_json({"end_of_stream": True})

    except WebSocketDisconnect:
        print("Client disconnected")
    except Exception as e:
        print(f"An error occurred: {e}")
        await websocket.send_json({"error": str(e)})
    finally:
        # Reset the interpreter's state for the next session if needed
        interpreter.reset()
        print("Connection closed and interpreter reset.")

